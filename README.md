# System-Design



𝟭. 𝗦𝗰𝗮𝗹𝗮𝗯𝗶𝗹𝗶𝘁𝘆: https://lnkd.in/dD-GZpVq

𝟮. 𝗟𝗮𝘁𝗲𝗻𝗰𝘆 𝘃𝘀 𝗧𝗵𝗿𝗼𝘂𝗴𝗵𝗽𝘂𝘁: https://lnkd.in/dscK9g3E

𝟯. 𝗖𝗔𝗣 𝗧𝗵𝗲𝗼𝗿𝗲𝗺: https://lnkd.in/dFpgDSnY

𝟰. 𝗔𝗖𝗜𝗗 𝗧𝗿𝗮𝗻𝘀𝗮𝗰𝘁𝗶𝗼𝗻𝘀: https://lnkd.in/dkkmMu_D

𝟱. 𝗥𝗮𝘁𝗲 𝗟𝗶𝗺𝗶𝘁𝗶𝗻𝗴: https://lnkd.in/dY9NqRG9

𝟲. 𝗔𝗣𝗜 𝗗𝗲𝘀𝗶𝗴𝗻: https://lnkd.in/dTgxGa5i

𝟳. 𝗦𝘁𝗿𝗼𝗻𝗴 𝘃𝘀 𝗘𝘃𝗲𝗻𝘁𝘂𝗮𝗹 𝗖𝗼𝗻𝘀𝗶𝘀𝘁𝗲𝗻𝗰𝘆: https://lnkd.in/dQDwa7TQ

𝟴. 𝗗𝗶𝘀𝘁𝗿𝗶𝗯𝘂𝘁𝗲𝗱 𝗧𝗿𝗮𝗰𝗶𝗻𝗴: https://lnkd.in/dA-3swq2

𝟵. 𝗦𝘆𝗻𝗰𝗵𝗿𝗼𝗻𝗼𝘂𝘀 𝘃𝘀. 𝗮𝘀𝘆𝗻𝗰𝗵𝗿𝗼𝗻𝗼𝘂𝘀 𝗰𝗼𝗺𝗺𝘂𝗻𝗶𝗰𝗮𝘁𝗶𝗼𝗻𝘀: https://lnkd.in/dx2nFDgR

𝟭𝟬. 𝗕𝗮𝘁𝗰𝗵 𝗣𝗿𝗼𝗰𝗲𝘀𝘀𝗶𝗻𝗴 𝘃𝘀 𝗦𝘁𝗿𝗲𝗮𝗺 𝗣𝗿𝗼𝗰𝗲𝘀𝘀𝗶𝗻𝗴: https://lnkd.in/dqGFQppV

𝟭𝟭. 𝗙𝗮𝘂𝗹𝘁 𝗧𝗼𝗹𝗲𝗿𝗮𝗻𝗰𝗲: https://lnkd.in/dzKWh4ju

GITHUB REPO to follow: 
1. https://github.com/ashishps1/awesome-low-level-design
2. https://lnkd.in/eWcNwskN

Check out this link: https://lnkd.in/d8Vag9kD
You'll find over 100 topics there! It's a fantastic resource for learning how to make robust systems.



## 🚀 Low Level Design (LLD) Made Easy!

### 🔹 1. Object-Oriented Design (OOD) Principles 

- SOLID: 5 design principles to create robust code – https://lnkd.in/dafK6TzQ 
- DRY (Don't Repeat Yourself): Reduce duplication – https://lnkd.in/dreUT7_h 
- KISS (Keep It Simple, Stupid): Simplicity wins – https://lnkd.in/d-nFYfdR
- YAGNI (You Aren’t Gonna Need It): Avoid over-engineering –https://lnkd.in/gKUzueF7


### 🔹 2. Must-Know Design Patterns 

- Singleton: One instance rule – https://lnkd.in/dB5aDUXr
- Factory: Simplify object creation – https://lnkd.in/dvZtfe-k
- Adapter: Interface bridge – https://lnkd.in/dKQpsTfe 
- Observer: Event-driven pattern – https://lnkd.in/dByc-whP
- Strategy: Dynamic behavior switching – https://lnkd.in/d9dz8ER7


### 🔹 3. System Components Design 

- Class Diagrams: Static structure – https://lnkd.in/d8_8rYCp 
- Sequence Diagrams: Flow of messages – https://lnkd.in/duPf_cJ2 
- Interfaces: Abstraction in design – https://lnkd.in/d8NzSRgG


### 🔹 4. Database Design 

- ER Diagrams: Entity relationships – https://lnkd.in/d6xygCrb
- Normalization: Data integrity – https://lnkd.in/dz7MCVaj 
- Relationships: 1:1, 1:N, M:N – https://lnkd.in/da3YTaJN


### 🔹 5. Concurrency & Multithreading 

- Thread Safety: Avoid race conditions – https://lnkd.in/dNe6FpfS
- Locks: Synchronization techniques – https://lnkd.in/dN2YdpvU 
- Atomic Operations: Indivisible actions – https://lnkd.in/dcfZF9Jb


### 🔹 6. Error Handling & Logging 

- Exception Handling: Catch and recover – https://lnkd.in/dkUHDGBu
- Logging Strategies: Trace and monitor – https://lnkd.in/dvikcadQ


### 🔹 7. API Design 

- RESTful API: Principles of web services – https://lnkd.in/dqDrkbDS
- Pagination: Manage large datasets – https://lnkd.in/dJfwFqmd
- Authentication: Secure your endpoints – https://lnkd.in/dQ94BgzQ


### 🔹 8. Scalability & Performance 

- Caching: Faster access to data – https://lnkd.in/deMQvEJ9 
- Load Balancing: Distribute workload – https://lnkd.in/dkeYMX74 
- Lazy Loading: Optimize resources – https://lnkd.in/dvcdY_RX


## Commonly asked System Design CONCEPT BASED interview topics
### 1. Horizontal vs Vertical Partitioning: https://bit.ly/3zyBRew
Vertical partitioning splits tables by columns, often separating different features. Horizontal partitioning splits tables by rows, distributing data across multiple servers. Vertical organizes data logically, while horizontal improves scalability + performance.

### 2. Apache Kafka: https://kafka.apache.org/
Kafka is a distributed streaming platform using a publish-subscribe model. It's fast due to sequential disk I/O, zero-copy principle, and efficient batching of messages. 

### 3. Rate Limiter: https://lnkd.in/dvvNjKue
A rate limiter controls the rate of requests a client can make to a service. It prevents overload and ensures fair resource usage.

### 4. JWT vs OAuth vs SAML: https://lnkd.in/dPqrcN3u
JWT is a compact, self-contained token for secure information transmission. OAuth is an authorization framework for delegated access. SAML is an XML-based standard for exchanging authentication and authorization data. 

### 5. Single Sign-On (SSO): https://lnkd.in/diU54_-s
SSO allows users to access multiple applications with one set of credentials. It typically uses a central authentication server and protocols like SAML/OAuth. 

### 6. Microservices vs Monolithic Architecture: https://bit.ly/4bAt2hv
Microservices architecture breaks an application into small, independent services. Monolithic architecture is a single, tightly-coupled unit. Microservices offer scalability while monoliths are simpler to develop + deploy.

### 7. Reverse Proxy vs Forward Proxy: https://bit.ly/3xOx6wO
A reverse proxy sits in front of web servers, forwarding client requests to backend servers. A forward proxy sits in front of clients, forwarding their requests to the internet. Reverse proxies are used for load balancing and security, while forward proxies are used for anonymity and filtering.

### 8. CAP Theorem: https://lnkd.in/dQhhe4jD
The CAP theorem states that a distributed system can only provide two of three guarantees: Consistency, Availability, and Partition tolerance. In practice, partition tolerance is necessary, so systems must choose between consistency and availability during network partitions.

### 9. Global Scale System Design:https://bit.ly/3RW8DMJ
Key considerations include data replication, CDN usage, distributed caching, efficient load balancing, and handling data consistency across regions. Latency management, regulatory compliance, and disaster recovery are also crucial for global systems.

### 10. Efficient Caching Strategy: https://lnkd.in/dfnP9keJ
Implement multi-level caching (browser, CDN, application server, database). Use appropriate cache invalidation strategies (TTL, event-based). Consider cache coherence for distributed systems.



